\chapter{Porting BaseX to the Android platform}
\label{sec:migration:porting-basex-to-android}
In this chapter it is shown how the BaseX database has been migrated to the Android platform.
To achieve this goal the source and target platforms are analyzed and all requirements are determined.
The main focus here is on the different software platforms and not the hardware specific aspects because of the big variety of systems and devices that run both platforms. 
Therefore the two virtual machines and their execution byteformats have been compared and also the specific Android internals.
In Section~\ref{sec:migration:problems-during-the-migration} it is illustrated which parts of the BaseX version has been changed and how to receive a working BaseX Android version.
The last section describes the problems which are occurred during the migration of the database to Android.


\section{Analyzing the source and target platforms} 
\label{sec:migration:analysing-the-source-and-target-platform}
In this section the two different platforms are analyzed.
The main part of it is the software part, because both platforms are running on a huge amount of hardware devices.
The source platform is the Java Virtual Machine (JVM) and the target platform is the Dalvik Virtual Machine (Dalvik VM, or DVM) in the Android environment.
The JVM and the DVM are both virtual machines (VM), but they vary in different ways.
A virtual machine is a simulated computer, which can be a whole system with all parts a computer provides.
Or it is an abstraction layer which provides the functionality to execute a program on every system that runs the virtual machine.
Unlike compiled machine code a program for a virtual machine is platform independent, because it does not matter on which operating system it is executed, as long as the virtual machine is available.
A disadvantage of this is the loss of speed, which is a result of the execution of the virtual machine and not only the program in general.~\cite{craig2006virtual}
\\
For both virtual machines the programming language Java is used, which is being compiled into code that the VMs understand and are able to execute.
Although both platforms are virtual machines they differ in some crucial ways.
One of the main difference is that the JVM is a stack based and the DVM is a register based virtual machine.
Also the DVM is optimized to be executed on mobile devices, which means that it is designed to use less memory and CPU usage than the JVM.
Lesser hardware usage implies also lesser battery usage, which is also a factor which should be considered in the field of mobile development.
Another difference which need to be considered is the host system, which is in the DVM case Android.
And on the opposite to this it could be Windows, Mac OS, or any Linux/Unix derivate for the JVM. 
This need to be considered if external sources will be used, like writing or reading a file.


\subsection{Comparison of the two virtual machines}
\label{sec:migration:comparison-of-the-two-virtual-machines}
Like in the chapter before mentioned both source and target platforms are using Java as a programming language.
Compared to other general purpose programming languages, for example C++, Java is not being compiled into machine code.
To execute Java code a virtual machine is required, which runs the compiled Java code.
However, like in Section~\ref{sec:migration:analysing-the-source-and-target-platform} mentioned both platforms have different virtual machines.
They differ in many kinds that the application developer not sees but need to consider.
\\
On of the most important difference is that the JVM is stack and the DVM is a register based virtual machine.
This difference helps the DVM to execute the same code in lesser operations than the JVM.
This means that the DVM need lesser CPU cycles than the JVM, which is an improvement that is necessary because of the lack of CPU resources in mobile devices and the aspect of the battery usage.
This can be demonstrated by looking at the instructions done by adding two integers.
The stack based virtual machine has to do four machine instructions, while the register based VM can do the operation in one instruction.
The reason for this is that the stack based VM needs to pop the two values first before it can add and store them back on the stack.
The instructions are \textit{pop 1, pop 2, add 1 2, push result}.\\
Figure~\ref{fig:stack-based-addition} illustrates the executed instructions of a addition with a stack based virtual machine.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.65]{images/stack-based-addition.png} 
\caption{The addition of two integers on a stack based virtual machine.}
\label{fig:stack-based-addition}
\end{center}
\end{figure}

Compared to this, the register based virtual machine just need one machine instruction to complete the same addition of two numbers.
The needed instruction is \textit{ADD R1, R2, R3}, which can be translated into add content of register 1 and register 2 and store it in register 3.
Figure~\ref{fig:register-based-addition} illustrates this by showing the add operation of the numbers one and two.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.65]{images/register-based-addition.png} 
\caption{The addition of two integers on a register based virtual machine.}
\label{fig:register-based-addition}
\end{center}
\end{figure}
This minimal example shows how the register based virtual machine uses lesser machine instructions compared to the stack based.
The disadvantage in this is that register based machine has to store the addresses, the registers, of the operands.
Which is not necessary at a stack based machine, because of the stack pointer that always directs to the actual operand using the Last In First Out (LIFO) principal.
This leads to the result, that stack based code is smaller than the corresponding register based code.
Although the Dalvik VM is a register based virtual machine, the executed byte code is not bigger than the equivalent JVM code.~\cite{shi2008virtual}\\
This is the result of the different format of the executable virtual machine code, which is illustrated in Chapter~\ref{sec:comparison-of-the-two-bytecode-formats}.
\\
The performed instructions which are executed on Dalvik VM are called bytecode.
To execute this instructions the DVM has an interpreter which interprets all instructions and performs them.
The difference to normal interpreted languages is, that the JVM interpreter do not need to check the syntax of the program.
This has been already done by the Java compiler which compiles the Java source code into class files.
Even if it is faster than other interpreted languages, it is still slower than compiled code which is executed directly on the hardware.
This so called machine code is faster because there is no layer between the executions and the hardware, which could slow down the execution.~\cite{aycock2003brief}
There is a technique which can improve a virtual machine in performance aspects by adding a Just In Time (JIT) compiler to it.
Generally it can be said, that a JIT compiler, used by a virtual machine, compiles heavy used code segments or very expensive calculations into the faster machine code.
There is a great number of different types of JIT compilers and how they work, the two used by the JVM and the DVM are:
\begin{itemize}
\item method-based
\item trace-based
\end{itemize}
The trace-based method works by looking at the most executed code fragments, especially loops, and compiles them into native machine code.\\
The method-based JIT mechanism is to compile whole methods, which are often used and expensive in execution time.
Since the release of the Android version 2.2, release name Froyo, the Dalvik VM has received a JIT compiler additionally to the interpreter mechanism.
According to \cite{cheng2010jit} the implemented Dalivk JIT compiler can speed up the execution of intensive operations up to five times.
The Dalvik VM uses the above mentioned mechanism of a trace-based JIT compiler mixed with the usual DVM interpreter.
The given advantage of the trace-based method is that not whole methods are being compiled into machine code.
Instead only the parts which are often executed are being compiled.
This reduces the size of the code which needs to be compiled by the JIT and also omits the not so often executed methods parts like exception handling.
It is needles to compile such parts in machine code to speed them up, because most of the execution time of the program they were not called.
It should also reduce the compile time for the JIT because of the selective compilation into machine code.\\
To realize this the DVM has received an additional thread, which is responsible for the JIT compilation.
Beneath this new thread there is the main thread, that includes the interpreter.
This interpreter interprets the bytecode and records the traces and their occurrence.
If the amount of the occurrence higher than a predefined number, the trace is being stored into the trace queue.
The new added thread, the JIT thread, compiles the traces from the queue and writes the machine code into the code cache.
The main thread now is doing a lookup if the bytecode that needs to be executed is now available in the code cache.
Is this condition met, it uses the machine code from the code cache instead interpreting the bytecode.\cite{oh2012evaluation}
Picture~\ref{fig:dvm-threads} illustrates the principle of the two threads in the DVM.\\
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{images/dvm-threads.png} 
\caption{The principle of the two DVM threads. Source:\cite{oh2012evaluation}}
\label{fig:dvm-threads}
\end{center}
\end{figure}

Depending on the different implementation of a JVM, it differs which type of JIT compiler mechanism is used.
For this thesis the Oracle JVM HotSpot is used, which has a method-based JIT compiler as default.
It is also possible to use another JIT mechanism in the HotSpot JVM triggered by parameters during the VM start.
The method-based JIT works like above mentioned, it compiles the most called methods into machine code.~\cite{kotzmann2008design}
Those methods are called hot spots, which are also named the virtual machine.
\cite{paleczny2001java}
\\
Although both virtual machines are using Java as programming language, Dalvik lacks of some libraries that are available at the JVM and vice versa.
In Section~\ref{sec:migration:migration-of-basex-to-android} the used libraries of BaseX are analyzed and investigated which of them are supported by the DVM.\\
A general statement about the both virtual machines could not be made, because they differ in a lot of aspects.
Especially that the DVM has been created for the mobile context and can only be ran on Android devices\footnote{There exist some community projects which are aiming to port the Dalvik VM to other platforms like Linux x86 for example\url{http://www.android-x86.org/}}.


\subsection{Comparison of the two bytecode formats}
\label{sec:comparison-of-the-two-bytecode-formats}
Both virtual machines differ in their format of the executable files.
This is on one side the Java Archive File (JAR) for the JVM and the Davlik Executable (\textit{dex}) on the other side.
This \textit{dex} is being packed into an Android Application package file (\textit{apk}) which can be executed by the Android operating system.
A JAR file is an archive which includes the compressed class files, this class files are being build out of the Java source code by using the javac compiler.~\cite{pugh1999compressing} 
An \textit{apk} file is also an archive file, but it not only includes the executable program, it also includes the meta information and resource files.
The executable which includes an \textit{apk} is called \textit{dex} file, which is short for Dalvik Executable.
A \textit{dex} file is created by using a tool which compiles Java class files into \textit{dex} files.
This works by a tool which is called dx and is part of the Android software development kit.
Picture~\ref{fig:create-apk} illustrates the flow of an \textit{apk} creation, which differs to the creation of a JAR file by creating \textit{dex} files out of the class files.\\
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.55]{images/create-apk.png} 
\caption{The creation flow of an \textit{apk} file.}
\label{fig:create-apk}
\end{center}
\end{figure}

Having a closer look at the \textit{dex} files and comparing them to the JAR files shows that they differ in various ways.
The first thing that comes in mind is that a JAR file contains a class file for every class.
And a \textit{dex} file combines all specific information into one field.
Which results in that it just has one constant pool, where all constant values of all classes are stored.
These constants are:
\begin{description}
  \item[string\_ids] Sorted list of all string identifiers
  \item[type\_ids] Sorted list of all identifiers of classes, arrays or primitive types
  \item[proto\_ids] Sorted list of all prototypes
  \item[field\_ids] Sorted list of all identifiers for the used fields
  \item[methods\_ids] Sorted list of all methods used by the \textit{dex} file
\end{description}
Thinking about an interface which is used very often in a project can display what an advantage of one shared constant pool gives.
Looking at Image~\ref{fig:jar-dex} demonstrates that every class which uses this interface needs has its own reference in its own constant pool.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.41]{images/jar-dex.png} 
\caption{The difference between a jar and a \textit{dex} file. Source:~\cite{enck2011study}}
\label{fig:jar-dex}
\end{center}
\end{figure}

In general it can be said that \textit{dex} files are smaller than their equivalent JAR files, because of the shared constant pool.~\cite{bornstein2008dalvik}
An advantage of the creation chain of a \textit{dex} file is that it is theoretically possible to create a \textit{dex} file out of every jar archive.
The problem hereby is that Android does not support all Java libraries that the JVM supports, but this can be done by using the above mentioned dx-tool. 
Like mentioned above this \textit{dex} file is executed by the Dalvik virtual machine, but it is not the Android application.
This application is the \textit{apk}  which includes also UI related information and other resource files, like images or sound.


\subsection{Android internals}
\label{sec:android-internals}
As shown in the Sections~\ref{sec:migration:comparison-of-the-two-virtual-machines} and \ref{sec:comparison-of-the-two-bytecode-formats} the two virtual machines and the bytecode formats differ.
However, Android has some other specialties about its internal processing.
The Android operating system is a Linux based operating system aimed to run on mobile devices.
Therefore it has been created as a Linux fork of the 2.6.*\footnote{Since Android version 4.* a Linux kernel 3.* is used} kernel and 
It is being especially designed for the mobile context.
Which includes special focus for the resource consumption, because most mobile devices provide not the same resources as a normal desktop PC or a notebook.
As shown in Section~\ref{sec:migration:comparison-of-the-two-virtual-machines} an Android application is executed on the Dalvik virtual machine.
Here it need to be said that every application runs its own Dalvik instance, by forking the main Dalvik instance into an own Linux process.
Here sets the Android policy in, that every application is independent from every other application and is executed in its own process.
This also is applied for the location of all files the application uses.
An application can be compared as an user in Linux, every application is its own user and has its own home directory.
This directory can only be accessed by the owning application and can be found in the /data/data directory.
This directory includes an own SQLite3 database, cache directory, shared preferences\footnote{Android framework that provides a mechanism to store primitive data types.} and every type of private data.
A reason for this is a security aspect as well as the stability of the application, considering the own Dalvik instance.
This is called the \textit{principle of least privilege} which specifies that as less as possible privileges are given to the application.
Therefore an application developer has to specify which privileges its application needs, for example Internet access or the possibility to write on the external SD-card.
It is possible that applications can communicate with predefined Inter Process Communications (IPC) but it is not possible to manipulate other applications.
This can be omitted by granting an application root privileges, but usually this is not possible on normal devices.
Hence, confidential data should also be encrypted,because it is theoretically possible to access the data in the private directory.
It also need to be mentioned that every operation which reads or writes to on of the above mentioned directories or files is an input output (IO) operation.
This is always expensive in time consumption and should be done as little as possible.
Image~\ref{fig:zygote-and-app} illustrates the principle that every application works in its own sandbox.\\
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.65]{images/zygote-and-app.png} 
\caption{Illustration of the Android application architecture}
\label{fig:zygote-and-app}
\end{center}
\end{figure}
The main Dalivk instance which is the root for all forked virtual machines is called Zygote and is started by the boot up process.
Zygote is designed to load and initialize the core library classes so that every forked instance do not have to do this.
This is compared to starting a new virtual machine a speed improvement and saves memory, because not every VM instance has its own core libraries loaded.
This can be done because the core libraries are all read only and shared by all Dalvik instances.\cite{ehringer2010dalvik}
Another difference to the usual Linux is that Android uses Bionic libc which is a special from Google developed library for Android which has its own pthread implementation.
This library is especially designed for the mobile context and the Android environment which improves the speed of forking the Dalvik virtual machine too.~\cite{brady2008android}
\newpage
\section{Migration of BaseX to Android}
\label{sec:migration:migration-of-basex-to-android}
After analyzing both platforms the BaseX database code need to be examined too.
Like it has been mentioned in Section~\ref{sec:migration:comparison-of-the-two-virtual-machines} the Dalvik virtual machine does not support all class libraries that are supported by the JVM.
BaseX is written in the Java programming language and aims to be executed on virtual machines that are implemented by using the JVM specifications.
Therefore it is not possible to transform the BaseX jar file into a \textit{dex} file, using the dx-tool, and execute it on an Android device.
On the other side the DVM offers class libraries that the JVM does not support or knows.
These libraries do not intent to replace not supported Java class libraries, there purpose is to provide special Android related methods, for example logging or tracing of method calls.

\subsection{Analyzing the libraries used by BaseX}
\label{sec:migration:analyzing-the-libraries-used-by-basex}
BaseX is a big project which includes up to 60 packages and more than 1300 classes, interfaces and abstract classes.
For this reason the examining of the used libraries and the dependencies a tool was used.
It is called Class Dependency Analyzer (CDA)\footnote{http://www.dependency-analyzer.org/} and offers all needed possibilities for the mentioned task.
Parsing the whole BaseX project lists the used Java class libraries and external libraries.
This list gives 54 packages that are part of the Java class library or an external library used by BaseX.
It has to be supposed that none of them are known to the Dalvik virtual machine.
Most of them are subpackages of packages and it can be expected that if a main package is not supported by Android the subpackage also not. 
This assumption reduces the external packages to a number of 16, which is compared to the before mentioned 54 packages an easier to analyze amount.
Looking at the Android documentation the main packages that are not supported are just the two graphical user interface GUI related packages:
\begin{itemize}
  \item java.awt\footnote{except the subpackage java.awt.font that provides two classes: NumericShaper and TextAttribute.}
  \item javax.swing
\end{itemize}
All others are full or partially supported by the Dalvik VM.
The reason why the packages awt and swing are not supported is that Android uses its own GUI libraries and framework.
The Android provided GUI elements can either be written as Java code or can be defined in XML layout files.
The framework offers everything that is needed to build an application with a graphical user interface.\\
Supporting the main packages does not mean that all subpackages, classes or even methods that are used from other libraries are also known by the DVM.
Therefore more investigation needs to be done.
To get a clearer statement the subpackages are also being checked if they are supported by the DVM.
The result of this investigation is that javax.xml is supported, but not the following subpackages:
\begin{itemize}
  \item javax.xml.crypto.dom
  \item javax.xml.crypto.dsig.dom
  \item javax.xml.crypto.dsig.keyinfo
  \item javax.xml.crypto.dsig.spec
\end{itemize}
Even if all packages and classes of javax.xml.crypto are part of the Java standard edition they are not available for Android development.
All classes inside this packages were only used by one BaseX package which is called org.basex.query.util.crypto.
This package is used to implement the XQuery Cryptographic module that provides functionalities to en- decrypt, sign and validated signed XML data.
The only class that uses this package is the FNCrypto class which is used to provide the Cryptographic module functionalities.
These are XQuery functions which are:
\begin{itemize}
  \item hmac(string,string,string[,string])
  \item encrypt(string,string,string,string)
  \item decrypt(string,string,string,string)
  \item generate-signature(node,string,string,string,string,string[,item][,item])
  \item validate-signature(node)
\end{itemize}
To provide these five XQuery functions on Android, the javax.xml.crypto package need to be migrated to Android too.
Or other cryptographic classes need to be used provided by Android.\\
All other subpackages are supported by the Android platform.
For clarification not all methods that are provided by every used library are checked if they are available on Android, this would be to much thinking about the amount of available classes.
Nevertheless this could be figured out in Section~\ref{sec:migration:creating-a-basex-android-library}

\subsection{The Android project structure}
\label{sec:migration:the-android-project-structure}
For developing Android applications an Android project need to be set up.
An Android project is a structure of special folders and predefined files, like code, resource and build files.
There are three types of Android projects, they differ in their functionalities and purposes.
The first is the type of project that needs to be created if an executable application is the goal of the development process.
As a result of this an installable \textit{apk} file will be created by the build process.
The seconds type of Android project is the so called Test project.
This type of projects aims to test executable Android projects by providing an Android testing framework with unit test.
Both projects have the same structure of folders and files.
The third project type is the library project which goal it is to be a library that can be used by every other Android project.
The difference to a normal Android project is that this project is not being build into an \textit{apk} file, it is being used by other Android projects which pull it in their \textit{apk} and build it with their code.
Depending on the Android API level an Android library differs from a usual Java library that it is not compressed into a jar archive.
This feature has been added in Android versions higher than API level 14, Android 4.0 codename Icecream Sandwich.
For the versions before this API level the library files were pulled into the project and compiled into the corresponding \textit{dex} file.\\
If a new Android application is developed it is not necessary to setup the right project structure by hand, therefore Android provides a Software Development Kit (SDK).
This SDK provides tools and utilities to create every type of Android project, it includes build, debug, trace and test tools.
With this SDK, which is also called Android Developer Tools (ADT), it is possible to create Android applications written in Java.
Like it was mentioned in Section~\ref{sec:comparison-of-the-two-bytecode-formats} the code that is translated into bytecode for the Dalvik virtual machine is written in the Java programming language.
Though, it is also possible to write code in C++ and compile it into native code, like it is done by the in Section~\ref{sec:migration:comparison-of-the-two-virtual-machines} referred JIT mechanism.
Therefore Google provides an Android Native Development Kit (NDK), that offers tools and a compiler to translate such native code.
If a project has been created there are seven given folders, shown in Table~\ref{tab:android-project-folders}.
\begin {table}[htpb] 
  \centering
\begin {tabular} {|l|l|}
	\hline
	src/&Contains the Java source code files\\
	\hline
	bin/&Contains the compiled output file\\
	\hline
	jni/&Contains C++ native code created by using the NDK\\
	\hline
	gen/&Contains automatic generated Java files\\
	\hline
	assets/&Is used for every kind of file, is packed into the \textit{apk} file as it is\\
	\hline
	res/&Contains all resource files\\
	\hline
	libs/&Contains private libraries\\
	\hline
\end {tabular}
\caption {Android project folders generated by the SDK.}
\label {tab:android-project-folders}
\end {table}

The files that will be appearing by creating a Android project are four build files that hold information for the build system to create the \textit{dex} files and the \textit{apk} archive.
Another file that is being created is the \textit{AndroidManifest.xml}.
This XML file is important for the application and the Android operating system.
It is used to specify the API level, the name and other specific information of the application.
In this file it is also possible to grant privileges to the application that are needed for specific functionalities.
For example accessing the Internet or writing on the external storage card.
Used libraries are also defined in this file, but if a library need some privileges and defines them into its own mainfest file, they are not granted by Android.
Therefore it is necessary to grant privileges in the Android project and not in the library project because those are being ignored.


\subsection{Creating a BaseX Android library}
\label{sec:migration:creating-a-basex-android-library}
For the migration of BaseX to the Android operating system a library project has been created.
The reason to make BaseX as library, like in Section~\ref{sec:migration:the-android-project-structure} explained, is that Android libraries can be used by many other projects.
After creating the library project all BaseX files has been copied to this project.
After this operation the GUI packages has been removed, those packages are \textit{basex.gui} and all subpackages.
As a result of this the depending classes of the GUI has also been removed, those are also not necessary because the BaseX library should not provide a graphical user interface.
Afterwards the not supported \textit{javax.xml.crypto} packages and the dependent class \textit{FNCrypto} have been removed.
Therefore it not possible to use the cryptological XQuery function in this BaseX Android version.\\
The result of removing all not supported packages, classes and libraries is that it is now possible to compile BaseX to an Android dex file.
Although it is not possible at this moment to execute BaseX, because of some constraints mentioned in Section~\ref{sec:android-internals}.
In a usual Linux environment BaseX stores all its database files in a directory in the normal user directory.
This means executing BaseX on Android without adjusting the directory to store the databases, would not work.
BaseX receives the name and location of the home directory of the user by calling the Java function \textit{System.getProperty(``user.home'')}, which works well with the JVM.
Using this function on Android gives an empty string and results in BaseX trying to save the database in the root directory, what is impossible because of the Android right system explained in Section~\ref{sec:android-internals}.
To avoid this behavior the above mentioned function need to be replaced.
The problem here is that BaseX should be a library project and it should be usable by every other Android project.
So it is impossible to say how the directory is named and located where the databases need to be stored.
An Android application receives its directory by the name of its main package and not by the name of the library main package.
Hence, it is necessary to tell the library this location and use this instead of its own package name.
To implement this an class has been created which is an entry point for the library and is the first instance when the BaseX Android library is used.
This class creates an object of the library and needs the package name as an argument for the method that returns an instance of its object.
To create the object the Singleton pattern has been used~\cite{gamma2010entwurfsmuster}.
The reason for this is that only one instance of the database can be created and used.
This class is called \textit{BaseXDatabase} and creates a BaseX Context object by calling a constructor that has been added to the Context class.
The newly created Context constructor checks if the given directory is available and if it is possible to read and write to this directory.
Is it the first time the constructor of the class is used, it creates an directory which is called \textit{BaseXData}.
All databases created and used by this Android application are stored inside this directory.
This directory is only accessible from this application.
At this moment it is possible to use BaseX as an Android library and it would create the needed BaseX directory.\\
To provide the BaseX operations the above mentioned class has been extended by additional methods which can be used for this purpose.
All are implemented by using the above mentioned Context object, which means every operation is executed on this object.\\
After this migration it is possible to use BaseX like it can be done on every usual PC.
Except the cryptographic XQuery function, the BaseX Android library offers all functionalities like the normal BaseX version offers.
The Android principle that every application works in its own sandbox is also being kept.
With this solution every application has its own BaseX database in its own directory, an advantage could be that the database does not need to synchronize a query.
The advantages and disadvantages of this solution are outlined and investigated in Chapter~\ref{cha:analysis}.
There also the validation of the BaseX Android library is shown and the performance analyzed.



\section{Problems during the migration}
\label{sec:migration:problems-during-the-migration}
There occurred several problems during the migration of BaseX to the Android operating system.
The first problem which was discovered, was the in Section~\ref{sec:migration:analyzing-the-libraries-used-by-basex} mentioned lack of some included libraries, that are not supported by Android.
To solve this problem they have been removed and their functionality has been deprecated.
This has been done, because this specific functionalities are not required for a first BaseX Android version.
This also applies for all graphical user interface components.\\
Another problem was the location of the BaseX database directory.
This need to be, like in Section~\ref{sec:android-internals} described, the \textit{/data/data/application-package-name} directory.
The problem hereby is that one of the goals of the migration is that the database is a library, but the directory name depends from the application name and not from the library name.
The only way to get the application way, except for hard coding, is to get the application context and extract the name there.
This bears another problem, though only applications have a context, libraries not. 
A possible way, could be to pass the context to the library, but then the library holds the context which it does not need.
It just needs the context to receive the application name and nothing more.
Holding a context massively slows down an Android application, so this is not the way how it was solved.
The alternative is to pass a string holding the application name to the library constructor.
And the library uses it to generate the needed directories.
Therefore the context has been used before creating a library instance to receive the needed directory name and this is passed to the library during the constructor.
This is also the way how it is done in the BaseX library, like it was described in Section~\ref{sec:migration:creating-a-basex-android-library}.\\
A problem at this solution is that the user directory which is used in BaseX is a static value initialized by the start of BaseX.
All static values used by BaseX are initialized at start-up in the static class \textit{Prop}.
And right after the start BaseX uses this value from this class in several places in the code.
Which means that it need to be changed before it is used anywhere in the code.
For this reason a trick has been used to initialize value before the constructor calls another constructor.
In the BaseX \textit{Context} class the constructor which calls the actual constructor has been changed to initialize this value as a parameter.
This results in the cycle of constructor calls, that the constructor which is called initializes the static values before calling the next constructor in the chain.
The corresponding Java code can be seen in Listing~\ref{lst:context-constructor}.
\input{listings/context-constructor}

Another problem which occurred during the migration, was that BaseX uses a lot of the String function \textit{isEmpty()}, which is not available at an Android API-level lower than 9.
The same applies for the \textit{copyOf()} method in the \textit{java.util.Arrays} package.
This was solved by not supporting API-level lower than 9 with BaseX library.
According to the official Android homepage only 1.7\% of the devices that are currently in circulation have an API-level lower than 9.\footnote{\url{http://developer.android.com/about/dashboards/index.html}}
The consequence of this would be that developers can only create applications that are executable on Android devices using an API-level higher than 9, when using the BaseX library.


